The Performance Schema contains the source of most of the lock information
available except for deadlocks. Not only can you use the lock information in the
Performance Schema directly; it is also used for two lock-related views in the
sys schema. Additionally, you can use the Performance Schema to investigate
the low-level synchronization objects such as mutexes. First, it will be shown
how metadata and table locks can be investigated.

performance_schema.metadata_locks
OBJECT_TYPE The kind of lock that is held such as GLOBAL for the global read lock and TABLE for tables and views.
OBJECT_SCHEMA The schema the object that is locked belongs to.
OBJECT_NAME The name of the locked object.
COLUMN_NAME For column level locks, the column name of the locked column.
OBJECT_INSTANCE_BEGIN The memory address of the object.
LOCK_TYPE The lock access level such as shared, exclusive, or intention. 
LOCK_DURATION How long the lock is held for. Supported values are STATEMENT,
TRANSACTION, and EXPLICIT.
LOCK_STATUS The status of the lock. In addition to a granted and pending status, it can also show that the lock request timed out, was a victim, etc.
SOURCE The place in the source code where the lock was requested.
OWNER_THREAD_ID The Performance Schema thread id of the thread that requested the lock.
OWNER_EVENT_ID The event id of the event requesting the lock.
The primary key of the table is the OBJECT_INSTANCE_BEGIN column.

performance_schema.data_locks 
ENGINE The storage engine for the data. For MySQL Server, this will always be InnoDB.
ENGINE_LOCK_ID The internal id of the lock as used by the storage engine. You should not rely on the id having a particular format.
ENGINE_TRANSACTION_ID The transaction id specific to the storage engine. 
THREAD_ID The Performance Schema thread id of the thread that made the lock request.
EVENT_ID The Performance Schema event id of the event that made the lock request. 
OBJECT_SCHEMA The schema the object that is subject of the lock request is in.
OBJECT_NAME The name of the object that is subject of the lock request.
PARTITION_NAME For locks involving partitions, the name of the partition.
SUBPARTITION_NAME For locks involving subpartitions, the name of the subpartition.
INDEX_NAME For locks involving indexes, the name of the index. Since everything is an index for InnoDB, the index name is always set for record level locks on InnoDB tables. 
GEN_CLUST_INDEX depending on whether you have an explicit primary key or the table used a hidden clustered index.
OBJECT_INSTANCE_BEGIN The memory address of the lock request.
LOCK_TYPE The level of the lock request. For InnoDB, the possible values are TABLE and RECORD.
LOCK_MODE The locking mode used. This includes whether it is a shared or exclusive lock and the finer details of the lock, for example, REC_NOT_GAP for a record lock but no gap lock.
LOCK_STATUS Whether the lock is pending (WAITING) or has been granted (GRANTED).
LOCK_DATA Information about the data that is locked. This can, for example, be the index value of the locked index record.
The primary key of the table is (ENGINE_LOCK_ID, ENGINE).

performance_schema.data_lock_waits
ENGINE The storage engine where the lock contention occurs.
REQUESTING_ENGINE_LOCK_ID The ENGINE_LOCK_ID for the pending lock.
REQUESTING_ENGINE_TRANSACTION_ID The ENGINE_TRANSACTION_ID for the pending lock.
REQUESTING_THREAD_ID The THREAD_ID for the pending lock.
REQUESTING_EVENT_ID The EVENT_ID for the pending lock.
REQUESTING_OBJECT_INSTANCE_BEGIN The OBJECT_INSTANCE_BEGIN for the pending lock.
BLOCKING_ENGINE_LOCK_ID The ENGINE_LOCK_ID for the blocking lock.
BLOCKING_ENGINE_TRANSACTION_ID The ENGINE_TRANSACTION_ID for the blocking lock.
BLOCKING_THREAD_ID The THREAD_ID for the blocking lock.
BLOCKING_EVENT_ID The EVENT_ID for the blocking lock.
BLOCKING_OBJECT_INSTANCE_BEGIN The OBJECT_INSTANCE_BEGIN for the blocking lock.

You can now monitor the waits using one of the events_waits_% tables :
events_waits_current: The current ongoing or last completed wait
events for each existing thread. This requires the
events_waits_current consumer to be enabled.
events_waits_history: The last ten (the performance_schema_events_waits_history_size option) wait events for each existing thread. This requires the
events_waits_history consumer to be enabled in addition to the
events_waits_current consumer.
events_waits_history_long: The last 10,000 (the performance_schema_events_waits_history_long_size option) events globally, including for threads that no longer exist. 
events_waits_summary_by_account_by_event_name: The wait events grouped by the username and hostname of the accounts (also called actors in the Performance Schema).
events_waits_summary_by_host_by_event_name: The wait events grouped by the hostname of the account triggering the event and event name.
events_waits_summary_by_instance: The wait events grouped by
events_waits_summary_by_thread_by_event_name: The wait events for currently existing threads grouped by the thread id and event name.
events_waits_summary_by_user_by_event_name: The wait events grouped by the username of the account triggering the event and event name.
events_waits_summary_global_by_event_name: The wait
events grouped by the event names. This table is useful to get an overview of how much time is spent waiting for a given type of event.


The sys schema can be considered a collection of views that serve as reports on
the Performance Schema and Information Schema as well as various utility
functions and procedures. 

sys.innodb_lock_waits view in the Performance Schema to return all cases of lock waits for InnoDB record locks.
sys.schema_table_lock_waits view works in a similar way but uses the metadata_locks table to return lock waits related to schema objects. 

INNODB_METRICS and sys.metrics
The InnoDB monitor report is useful for a database administrator to get an
overview of what is going on in InnoDB, but for monitoring it is not as useful as
it requires parsing to get out the data in a way monitoring can use it.

information_schema.INNODB_METRICS


Lock Access Levels

Shared Locks
When a thread needs to protect a resource, but it is not going to change the
resource, it can use a shared lock to prevent other threads from changing the
resource while still allowing them to access the same resource. This is the most
commonly used access level.

Exclusive Locks
Exclusive locks are the counterpart to shared lock. They ensure that only the
thread granted the exclusive lock can access the resource for the duration of the
lock. As exclusive locks are used to ensure only one thread is modifying a
resource at a time, they are also known as write locks.
Exclusive locks are mostly obtained by data definition language (DDL)

Intention Locks
In the two examples this far in this chapter, there have been intention locks .
What are those? It is a lock that signals the intention of an InnoDB transaction
and can be either shared or exclusive. 


High-Level Lock Types
You manipulate user-level locks with a set of functions:
GET_LOCK(name, timeout): Obtains a lock by specifying the name
of the lock. The second argument is a timeout in seconds; if the lock is not
obtained within that time, the function returns 0. If the lock is obtained, the
return value is 1. If the timeout is negative, the function will wait indefinitely
for the lock to become available.
IS_FREE_LOCK(name): Checks whether the named lock is available
or not. The function returns 1 if the lock is available and 0 if it is not
available.
IS_USED_LOCK(name): This is the opposite of the
IS_FREE_LOCK() function. The function returns the connection id of the
connection holding the lock if the lock is in use (not available) and NULL if it
is not in use (available).
RELEASE_ALL_LOCKS(): Releases all user-level locks held by the
connection. The return value is the number of locks released.
RELEASE_LOCK(name): Releases the lock with the provided name.
The return value is 1 if the lock is released, 0 if the lock exists but is not
owned by the connection, or NULL if the lock does not exist.

Flush Locks
A flush lock will be familiar to most who have been involved in taking backups.
It is taken when you use the FLUSH TABLES statement and last for the duration
of the statement unless you add WITH READ LOCK in which case a shared
(read) lock is held until the lock is explicitly released. An implicit table flush is
also triggered at the end of the ANALYZE TABLE statement. The flush lock is a
table-level lock. The read lock taken with FLUSH TABLES WITH READ
LOCK is discussed later under explicit table locks.

Metadata Locks
Metadata locks are one of the newer lock types in MySQL. They were
introduced in MySQL 5.5, and their purpose is to protect the schema, so it does
not get changed while queries or transactions rely on the schema to be
unchanged. Metadata locks work at the table level, but they should be considered
as an independent lock type to table locks as they do not protect the data in the
tables.

Explicit Table Locks
Explicit table locks are taken with the LOCK TABLES and the FLUSH
TABLES WITH READ LOCK statements. With the LOCK TABLES statement,
it is possible to take shared or exclusive locks; FLUSH TABLES WITH READ
LOCK always takes a shared lock. The tables are locked, until they are explicitly
released with the UNLOCK TABLES statement. When FLUSH TABLES WITH
READ LOCK is executed without listing any tables, the global read lock (i.e.,
affecting all tables) is taken. While these locks also protect the data, they are
considered as metadata locks in MySQL.

Backup Locks
The backup lock is an instance-level lock; that is, it affects the system as a
whole. It is a new lock introduced in MySQL 8. The backup lock prevents
statements that can make a backup inconsistent while still allowing other
statements to be executed concurrently with the backup. Currently the primary
user of the backup lock is MySQL Enterprise Backup which uses it together with
the log lock to avoid executing FLUSH TABLES WITH READ LOCK for
InnoDB tables. The statements that are blocked include

Log Locks
When you create a backup, you typically want to include information about the
log positions and GTID set the backup is consistent with. In MySQL 5.7 and
earlier, you needed the global read lock while obtaining this information. In
MySQL 8, the log lock was introduced to allow you to read information such as
the executed global transaction identifiers (GTIDs), the binary log position, and
the log sequence number (LSN) for InnoDB without taking a global read lock.




